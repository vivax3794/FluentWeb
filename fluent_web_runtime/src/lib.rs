#![allow(incomplete_features)]
#![cfg_attr(feature = "nightly", feature(specialization))]
#![warn(
    clippy::pedantic,
    clippy::clone_on_ref_ptr,
    clippy::create_dir,
    clippy::filetype_is_file,
    clippy::fn_to_numeric_cast_any,
    clippy::if_then_some_else_none,
    missing_docs,
    clippy::missing_docs_in_private_items,
    missing_copy_implementations,
    missing_debug_implementations,
    clippy::missing_const_for_fn,
    clippy::mixed_read_write_in_expression,
    clippy::panic,
    clippy::partial_pub_fields,
    clippy::same_name_method,
    clippy::str_to_string,
    clippy::suspicious_xor_used_as_pow,
    clippy::try_err,
    clippy::unneeded_field_pattern,
    clippy::use_debug,
    clippy::verbose_file_reads,
    clippy::expect_used
)]
#![deny(
    clippy::unwrap_used,
    clippy::unreachable,
    clippy::unimplemented,
    clippy::todo,
    clippy::dbg_macro,
    clippy::error_impl_error,
    clippy::exit,
    clippy::panic_in_result_fn,
    clippy::tests_outside_test_module
)]

//! `FluentWeb` runtime libraries
//! This provides functions for your own code, as well as internal functions used by code generated by
//! `fluent_web`

#[doc(hidden)]
pub mod internal;

#[doc(hidden)]
pub use paste::paste;

/// Render a component at the specified `id`
/// This is a convenient wrapper around the internal `render_componet` function
/// Which abstracts away the implementation details of a `.fluent` module.
///
/// # What is actually does
/// This simply adds `::Component` to the path
/// `render_component!(App, "mount")` => `internal::render_component::<App::Component>("mount")`
#[macro_export]
macro_rules! render_component {
    ($($path:ident)::* , $id:expr) => {
        $crate::internal::render_component::<$($path)::*::Component>($id);
    };
    ($($path:ident)::* < $($generic:ty),* >, $id:expr) => {
        $crate::internal::render_component::<$($path)::*::Component<$($generic),*>>($id);
    };
}

/// This is just a direct call to `std::mem::forget` with a trait bound on `Component`
pub const fn forget<C: internal::Component>(comp: internal::Wrapped<C>) {
    std::mem::forget(comp);
}

/// Reference to a component
pub type CompRef<T> = internal::WeakRef<T>;

/// Repeat a function every time.
///
/// # Panics
/// If js envrioment is corrupted
#[allow(clippy::unwrap_used)]
pub fn internal<F: Fn() + 'static>(func: F, time_ms: i32) {
    use wasm_bindgen::JsCast;

    let function = wasm_bindgen::closure::Closure::<dyn Fn()>::new(func);
    let js_function = function.as_ref().unchecked_ref();

    let window = web_sys::window().unwrap();
    window
        .set_interval_with_callback_and_timeout_and_arguments_0(js_function, time_ms)
        .unwrap();
    function.forget();
}

/// Repeat a function in time.
///
/// # Panics
/// If js envrioment is corrupted
#[allow(clippy::unwrap_used)]
pub fn after<F: Fn() + 'static>(func: F, time_ms: i32) {
    use wasm_bindgen::JsCast;

    let function = wasm_bindgen::closure::Closure::<dyn Fn()>::new(func);
    let js_function = function.as_ref().unchecked_ref();

    let window = web_sys::window().unwrap();
    window
        .set_timeout_with_callback_and_timeout_and_arguments_0(js_function, time_ms)
        .unwrap();
    function.forget();
}
